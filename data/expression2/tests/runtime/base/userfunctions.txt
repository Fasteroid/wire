## SHOULD_PASS:EXECUTE

local X = 500
local Y = 1000
local Z = 5000

function test(X, Y, Z) {
	assert(X == 1)
	assert(Y == 2)
	assert(Z == 3)
}

test(1, 2, 3)

assert(X == 500)
assert(Y == 1000)
assert(Z == 5000)

function number:method(X, Y, Z) {
	assert(This == 500)
	assert(X == 1)
	assert(Y == 2)
	assert(Z == 4)
}

500:method(1, 2, 4)

assert(X == 500)
assert(Y == 1000)
assert(Z == 5000)

function number returning() {
	return 5
}

assert(returning() == 5)

function number returning2(X:array) {
	return X[1, number] + 5
}

assert(returning2(array(5)) == 10)
assert(returning2(array()) == 5)

function array returningref(X:array) {
	return X
}

local A = array()
assert(returningref(A):id() == A:id())

function returnvoid() {
	if (1) { return }
}

returnvoid()

function void returnvoid2() {
	return
}

returnvoid2()

function returnvoid3() {
	return void
}

returnvoid3()

function number recurse(N:number) {
	if (N == 1) {
		return 5
	} else {
		return recurse(N - 1) + 1
	}
}

assert(recurse(10) == 14, recurse(10):toString())

Sentinel = -1
function recursevoid() {
	Sentinel++
	if (Sentinel == 0) {
		recursevoid()
	}
}

recursevoid()

assert(Sentinel == 1)

# Now check variadic syntax sugar

function number number:foo(...A:table) {
	assert(A:typeids()[1, string] == "s")
	assert(A:typeids()[2, string] == "n")

	assert(A[1, string] == "foo")
	assert(A[2, number] == 55)

	return This
}

assert(5:foo("foo", 55) == 5)

function number number:bar(...A:array) {
	assert(A[1, string] == "foo")
	assert(A[2, number] == 55)

	return This
}

assert( 5:bar("foo", 55) == 5 )

CalledA = 0
function a() {
	CalledA = 1
}

if (0) {
	function a() {
		error("unreachable")
	}
}

a()
assert(CalledA == 1)

CalledB = 0
function number:b() {
	CalledB = 1
}

if (0) {
	function number:b() {
		error("unreachable")
	}
}

1:b()
assert(CalledB == 1)